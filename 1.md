1. Code Cleaning & Structure
Remove unused variables, imports, and legacy code.
Use consistent formatting (indentation, spacing, semicolons).
Group related logic (helpers, middleware, route handlers).
Avoid deep nesting; refactor complex logic into helper functions.
2. Comments & Documentation
Add a file-level header describing the fileâ€™s purpose and standards.
Document each route with:
HTTP method and path
Purpose/behavior
Access control (roles, authentication)
Expected request params/body
Response structure
Inline comments for non-obvious logic, error handling, and edge cases.
3. Error Handling
Use try/catch for all async route handlers.
Log errors with context.
Return clear, consistent error responses (status code, message).
4. Security & Access Control
Enforce authentication and role-based authorization for every route.
Validate all user input (query, params, body) with express-validator.
Never expose sensitive fields in responses.
5. Serverless Compatibility
Ensure models and resources are initialized per request (not globally).
Avoid global state or side effects.
6. Response Consistency
Always exclude sensitive fields (passwords, tokens).
Use consistent response formats (e.g., { data, message } or { error }).
7. Maintainability
Use helper functions for repeated logic (model loading, validation).
Keep route handlers concise; move business logic to services/helpers.
8. Audit & Compliance
Use audit middleware for create/update/delete actions.
Document audit logic in comments.